#include <iostream>
#include <vector>
/*
1. для тього чтобы создать обьект вектора требуется указать полный тип в качестве типа для работы
2. для работы основных методов класса тип для работы должен содержать:
    конструктор по умолчанию
    конструктор копирования
    присваивание копированием
    деструктор
3. для работы методов заполнения требуется наличие конструктора с параметром

*/
class Demo
{
public:
    Demo()
    { 
        std::cout << "Def constructor\n";
    };

    Demo(int val):a(val)
    {
        std::cout << "Param constructor";
    };

    Demo(const Demo&other):a(other.a)
    {
        std::cout << "Copy constructor";
    }

    ~Demo()
    {
        std::cout << "Def destructor";
    }

private:
    int a;

};
int main()
{
    //1
    std::vector<int> arr;//вектор от полного типа int
    //std::vector<int> arr;//вектор от  неполного типа void
    //первая строчка пройдет компиляцию, а вторая сломиает прграмму такая же история произойдет если вы попробуете создать вектор от абстрактного класса
    
    //2
    std::vector<Demo> arr3(3);
    //при содании вектора в его конструктор можно передать число, это создаст вектор в котором будет такое числопустых элементов
    //это создаст вектор в котором будет такое число пустых элементов, данный конструктор будет каботать только если конструтор по уиолчанию у хранимого класса
    
    arr3.reserve(1000);
    //метод резервирует под использование память на столько элементов, сколько указали, но не создает их сразу
    //При прочих равных правильнее созадавать вектор пустышек конструктором
    //вероника гуляева
    arr3.resize(20);
    //изменяет размер хранимых элементов(их количество), если новый размер больше, то в конец массива добавляются пустышки
    // если новый размер меньше  текущего кол-ва то всек не поместившееся уничтожаются
    arr3.shrink_to_fit();
    // не изменяет количество хранимых элеентов но освобождает неиспользуемый коллекцйией кусок памяти
    
    arr3.push_back(Demo(4));
    arr3.emplace_back(6);
    //для классов с конструктором от 2ч параметров и более emplace всегда принмает набор аргуметов конструтора и не вызывает конструторов копитрования

    return 0;

}
